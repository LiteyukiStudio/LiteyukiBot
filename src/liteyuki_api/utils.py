import asyncio
import json
import os
import traceback
from typing import Tuple, Dict, Iterable

import aiohttp
import nonebot
import nonebot.drivers
import requests
from nonebot import logger
from requests import Response

from .config import config_data, Path
from .data import Data

generate_signature = "Generated by LiteyukiBot %s" % config_data["version_name"]
text_language_map: Dict[str, Dict[str, str]] = {}

def load_text_hash_map() -> dict:
    nonebot.logger.info("Loading language text_map...")
    for file in os.listdir(os.path.join(Path.src, "text_map")):
        whole_path = os.path.join(os.path.join(Path.src, "text_map"), file)
        try:
            if file.endswith(".json") and os.path.isfile(whole_path):
                language_data = json.load(open(whole_path, encoding="utf-8"))
                text_language_map[file.replace(".json", "")] = language_data
                logger.success(f"Successfully load language: {file.replace('.json', '')}-{language_data.get('name', 'Unknown')}")
        except:
            logger.error(f"Load language file failed: {whole_path}")
load_text_hash_map()

async def get_text_by_language(hash_id: str, lang_or_uid: str | int=None):
    """
    多语言文本

    :param hash_id:
    :param lang_or_uid: 不传入默认为bot语言，若bot语言没有该词条，那么使用最广泛的中文
    :return:
    """

    bot_language = await Data(Data.globals, "liteyuki").get("language", "chs")
    if lang_or_uid is None:
        # 传入语言名
        lang_or_uid = await Data(Data.globals, "liteyuki").get("language", "chs")
    if isinstance(lang_or_uid, int):
        # 传入uid
        lang_or_uid = await Data(Data.users, lang_or_uid).get("language", bot_language)
    try:
        if lang_or_uid not in text_language_map:
            logger.error(f"No such language in text_map: {lang_or_uid}")
            lang_or_uid = bot_language
        elif str(hash_id) not in text_language_map[lang_or_uid]:
            logger.warning(f"No such text hash_id in {lang_or_uid}: {str(hash_id)}")
            lang_or_uid = bot_language
        return text_language_map[lang_or_uid][str(hash_id)]
    except:
        logger.warning(f"No such text hash_id in {lang_or_uid}: {str(hash_id)}")
        return text_language_map["chs"].get(str(hash_id), "chsNoText")


def clamp(x, _min, _max):
    if x < _min:
        return _min
    elif _min <= x <= _max:
        return x
    else:
        return _max


def average(_iterable: Iterable) -> float:
    total = sum(_iterable)
    return total / len(_iterable)


def download_file(url, file, chunk_size=1024, force=False):
    """
    :param url: 链接
    :param file: 文件路径
    :param chunk_size:
    :param force: 强制下载，即使本地存在
    :return:
    """
    if os.path.exists(file) and not force:
        nonebot.logger.info(f"File already exist: {file}, Skip download.")
    try:
        headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.66 Safari/537.36'}
        if not os.path.exists(os.path.dirname(file)):
            os.makedirs(os.path.dirname(file))
        response_data_file = requests.get(url, stream=True, headers=headers)
        with open(file, 'wb') as f:
            for chunk in response_data_file.iter_content(chunk_size=chunk_size):
                if chunk:
                    f.write(chunk)
        nonebot.logger.info(f"Download Success: {url} {file}")
    except BaseException as e:
        nonebot.logger.warning(f"Download Failed: {url} {file}({traceback.format_exception(e)})")


def simple_request_get(url, **kwargs) -> Response:
    """同步简易请求函数"""
    resp = requests.get(url, **kwargs)
    return resp


async def simple_request_async(method, url, **kwargs):
    """异步简易请求函数"""
    async with aiohttp.request(method, url, **kwargs) as resp:
        return resp


def size_text(byte: int, dec: int = 2) -> str:
    """
    :param byte:
    :param dec: 浮点位数
    :return:
    """
    """1024转为1kb"""
    if (size := byte / 1024 ** 4) > 1:
        unit = "TB"
    elif (size := byte / 1024 ** 3) > 1:
        unit = "GB"
    elif (size := byte / 1024 ** 2) > 1:
        unit = "MB"
    elif (size := byte / 1024 ** 1) > 1:
        unit = "KB"
    else:
        unit = "B"
    return "%s%s" % (round(size, dec), unit)


def time_format_list(seconds: int) -> list:
    times = []
    secs = [31104000, 2592000, 86400, 3600, 60, 1]
    for sec in secs:
        times.append(seconds // sec)
        seconds = seconds % sec
    return times


def time_to_cn_by_sec(seconds) -> str:
    """
    时长文本带汉字单位： 3年4个月5天12小时32分12秒

    :param seconds
    :return:
    """
    time_list = time_format_list(seconds)
    text = ""
    show = False
    units = [
        "年", "个月", "日", "时", "分", "秒"
    ]
    for value, unit in zip(time_list, units):
        if value > 0:
            show = True
        if show:
            text += "%s%s" % (value, unit)
    return text


def time_to_hms_by_sec(seconds) -> str:
    """
    时长文本仅到时分秒： 23:23:23

    :param seconds
    :return:
    """
    return f"{seconds // 3600}:{seconds % 3600 // 60}:{seconds % 3600 % 60}"


def get_local_version() -> Tuple[str, int, int]:
    """
    :return: 版本名称， 版本id, 资源id
    """
    version_data = config_data
    if os.path.exists(os.path.join(Path.res, ".git")) and os.path.exists(os.path.join(Path.res, "version.json")):
        version_data_res = json.load(open(os.path.join(Path.res, "version.json"), encoding="utf-8"))
        return version_data["version_name"], version_data["version_id"], version_data_res["version_id"]
    else:
        return version_data["version_name"], version_data["version_id"], -1


def get_depository_version() -> Tuple[str, int, int]:
    """
    :return: 仓库版本名称， 版本id 资源id
    """
    url = "https://gitee.com/snowykami/liteyuki-bot/raw/master/src/config/config.json"
    data = simple_request_get(url).json()
    url = "https://gitee.com/snowykami/liteyuki-resource/raw/master/version.json"
    data_res = simple_request_get(url).json()
    return data["version_name"], data["version_id"], data_res["version_id"]


class Command:

    @staticmethod
    def get_keywords(old_dict: dict, keywords: dict) -> dict:
        """
        :param keywords:
        :param old_dict:
        :return:

        提取旧字典中设定键合成新字典
        """
        new = dict()
        for key in keywords:
            new[key] = old_dict.get(key, keywords[key])
        return new

    @staticmethod
    def formatToCommand(cmd: str, sep: str = " ", kw=True, exe=False) -> Tuple[Tuple, Dict]:
        """
        :param exe: 执行为Python对象，失败则为字符串
        :param kw: 将有等号的词语分出
        :param sep: 分隔符,默认空格
        :param cmd: "arg1 arg2 para1=value1 para2=value2"
        :return:

        命令参数处理
        自动cq去义
        "%20"表示空格
        """
        cmd = Command.escape(cmd, blank=False)
        cmd_list = cmd.strip().split(sep)
        args = []
        keywords = {}
        for arg in cmd_list:
            arg = arg.replace("%20", " ")
            if "=" in arg and kw:
                value = arg.split("=")[1]
                if exe:
                    try:
                        value = eval(value)
                    except:
                        pass
                keywords[arg.split("=")[0]] = value
            else:
                if exe:
                    try:
                        arg = eval(arg)
                    except:
                        pass
                args.append(arg)
        args = tuple(args)
        return args, keywords

    @staticmethod
    def formatToString(*args, **keywords) -> str:

        """
        :param args:
        :param keywords:
        :return:
        escape会将空格转为%20，默认False不转，会将空格转为%20
        """

        string = ""
        for arg in args:
            string += Command.escape(arg) + " "
        kw_item = keywords.items()
        for item in kw_item:
            kw = "%s=%s" % (item[0], item[1])

            string += Command.escape(kw) + " "
        return string[:-1]

    @staticmethod
    def escape(text: str, blank=True) -> str:
        """
        CQ码去义

        :param text:
        :param blank: 转义%20为空格
        :return:
        """
        escape_data = {
            "&amp;": "&",
            "&#91;": "[",
            "&#93;": "]",
            "&#44;": ","
        }
        for esd in escape_data.items():
            text = text.replace(esd[0], esd[1])
        return text.replace("%20", " " if blank else "%20")
